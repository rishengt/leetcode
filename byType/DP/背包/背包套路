一般当你确定一个问题是背包问题的时候，你就知道要用两次for loop 来解决了， 一次 for loop 便利物品的数量，一次for loop 便利要求达到amount的大小

标准01背包

给N件物品（价值为v，重量为w），每个物品只能用一次，背包总容量上限是c。问最大能装多少价值的东西。

状态定义：dp[i][c] -> 考虑仅在前i件物品的子集中选择，且代价（所选物品的总重量）恰好是c时能得到的最大收益。
状态转移：当前的代价是c，那么前一轮的代价是多少？c或者 c-Wi
初始化：要求恰好填满背包的时候 dp[0][0] = 1因为 如果要求背包恰好装满，那么此时只有容量为 0 的背包可以在什 么也不装且价值为 0 的情况下被“恰好装满”，
其它容量的背包均没有合法的解，属于 未定义的状态，应该被赋值为 -1了。
如果背包并非必须被装满，那么任何容量的背包 都有一个合法解“什么都不装”，这个解的价值为 0，所以初始时状态的值也就全部为 0 了。

for(int i = 1; i<=N; i++){
    for(int c = 1; c<=C; c++){
    dp[i][c] = max(dp[i-1][c],dp[i-1][c-Wi]+vi);
    }
}
ANS = max{dp[N][c]} for c=1,2,......,C